const { chromium, firefox } = require("playwright");

let browserInstance = null;

const getOrCreateBrowser = async (browserType = null) => {
  if (browserInstance) {
    return browserInstance;
  }

  const BROWSER_TYPES = [chromium, firefox];
  const selectedType = browserType || BROWSER_TYPES[Math.floor(Math.random() * BROWSER_TYPES.length)];

  browserInstance = await selectedType.launch({
    headless: true,
    args: [
      '--disable-blink-features=AutomationControlled',
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
    ],
  });

  return browserInstance;
};


const closeBrowser = async () => {
  if (browserInstance) {
    await browserInstance.close();
    browserInstance = null;
  }
};

const isJsRendered = (html) => {
  if (!html || typeof html !== "string") return true;

  const lowerHtml = html.toLowerCase();

  // 1. Check for actual content in the initial HTML
  const hasContent = () => {
    // Look for substantial text content
    const textContent = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
    if (textContent.length > 200) return false; // Has meaningful text = probably static
    
    // Check for multiple content elements
    const contentElements = (lowerHtml.match(/<(p|h1|h2|h3|h4|h5|h6|article|section|main|div[^>]*class="[^"]*content)/g) || []).length;
    return contentElements < 3; // Few content elements = likely JS rendered
  };

  // 2. Check for JS framework patterns (these indicate client-side rendering)
  const jsFrameworkPatterns = [
    // Empty containers
    '<div id="root"></div>',
    '<div id="app"></div>',
    '<div id="__next"></div>',
    '<div id="gatsby-focus-wrapper"></div>',
    
    // Script tags with specific patterns
    /<script[^>]*src="[^"]*react[^"]*\.js"/i,
    /<script[^>]*src="[^"]*vue[^"]*\.js"/i,
    /<script[^>]*src="[^"]*angular[^"]*\.js"/i,
    
    // Common patterns for client-side rendered apps
    /<div[^>]*class="[^"]*react-root/i,
    /<div[^>]*id="root"[^>]*>[\s\n]*<\/div>/i,
  ];

  for (const pattern of jsFrameworkPatterns) {
    if (pattern instanceof RegExp) {
      if (pattern.test(html)) return true;
    } else if (lowerHtml.includes(pattern.toLowerCase())) {
      return true;
    }
  }

  // 3. Check body content density
  const bodyMatch = lowerHtml.match(/<body[^>]*>([\s\S]*?)<\/body>/);
  if (bodyMatch) {
    const bodyContent = bodyMatch[1];
    
    // If body is almost empty (just scripts and styles)
    const bodyWithoutScripts = bodyContent.replace(/<script[\s\S]*?<\/script>/gi, '')
                                         .replace(/<style[\s\S]*?<\/style>/gi, '')
                                         .replace(/\s+/g, '');
    
    if (bodyWithoutScripts.length < 50) return true;
  }

  // 4. Check for server-side rendered indicators (opposite of JS-rendered)
  const ssrIndicators = [
    '<!-- server-rendered',
    'data-server-rendered',
    'ssr',
    '<!-- static content',
    '<!-- generated by',
    '<meta name="generator" content="',
  ];

  for (const indicator of ssrIndicators) {
    if (lowerHtml.includes(indicator)) return false;
  }

  // 5. Check if there are meaningful visible elements
  const visibleElements = (html.match(/<(a|p|h1|h2|h3|h4|img|button|input|form|table|ul|ol|li|div[^>]*class="[^"]*container)/gi) || []).length;
  
  if (visibleElements < 5 && hasContent()) {
    return true; // Likely JS rendered with minimal static HTML
  }

  return false; // Default to static HTML
};

module.exports = {
  getOrCreateBrowser,
  closeBrowser,
  isJsRendered
};